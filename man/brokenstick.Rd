% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/brokenstick.R
\name{brokenstick}
\alias{brokenstick}
\alias{brokenstick.default}
\alias{brokenstick.formula}
\alias{brokenstick.recipe}
\alias{brokenstick.data.frame}
\alias{brokenstick.matrix}
\title{Fit a \code{brokenstick} model to irregular data}
\usage{
brokenstick(x, ...)

\method{brokenstick}{default}(x, ...)

\method{brokenstick}{formula}(
  formula,
  data,
  ...,
  knots = NULL,
  boundary = NULL,
  k = NULL,
  control = control_brokenstick()
)

\method{brokenstick}{recipe}(
  x,
  data,
  ...,
  knots = NULL,
  boundary = NULL,
  k = NULL,
  control = control_brokenstick()
)

\method{brokenstick}{data.frame}(
  x,
  y,
  group,
  ...,
  knots = NULL,
  boundary = NULL,
  k = NULL,
  control = control_brokenstick()
)

\method{brokenstick}{matrix}(
  x,
  y,
  group,
  ...,
  knots = NULL,
  boundary = NULL,
  k = NULL,
  control = control_brokenstick()
)
}
\arguments{
\item{x}{Predictor variables. Depending on the context:
\itemize{
\item A \strong{data frame} of predictors.
\item A \strong{matrix} of predictors.
\item A \strong{recipe} specifying a set of preprocessing steps
created from \code{\link[recipes:recipe]{recipes::recipe()}}.
}

If \code{x} has one column, then also specify \code{y} and \code{group}. If \code{x} has multiple
columns, then specify the model by a \code{formula} argument.}

\item{...}{Not currently used, but required for extensibility.}

\item{formula}{A formula specifying the outcome terms on the
left-hand side, the predictor term on the right-hand side and
the group variable after the \code{|} sign, e.g \code{formula = hgt ~ age | id}.
One may specify additional variables, but the \code{brokenstick} model
will ignored them.

Note: This formula specification is specific to the \code{brokenstick()}
function, and generates the error
\verb{No in-line functions should be used here} if passed directly to
\code{recipes::recipe()}. See examples.}

\item{data}{When a \strong{recipe} or \strong{formula} is used, \code{data} is specified as:
\itemize{
\item A \strong{data frame} containing predictor, group and outcome variables.
}}

\item{knots}{Optional, but recommended. Numerical vector with the
locations of the breaks to be placed on the values of the predictor.
Values outside the range of the data will extend the \code{boundary}
knots (see below) beyond the data range.}

\item{boundary}{Optional, but recommended. Numerical vector of
length 2 with the left and right boundary knots. The \code{boundary}
setting is passed to \code{\link[splines:bs]{splines::bs()}} as the \code{Boundary.knots} argument.
If not specified, then the range of predictor variable is taken. Since
the range depends on the data, it is recommended to specify \code{boundary}
explicitly. Note the the \code{boundary} range is internally expanded
to include at least \code{range(knots)}.}

\item{k}{Optional, a convenience parameter for the number of
internal knots. If specified, then \code{k} internal knots are placed
at equidense quantiles of the predictor. For example,
specifying \code{k = 1} puts a knot at the 50th quantile (median),
setting \code{k = 3} puts knots at the 25th, 50th and 75th quantiles,
and so on.

Note: Knots specified via \code{k} are data-dependent
and do not transfer to other data sets. We recommend
using \code{knots} and \code{boundary} over \code{k}. If both \code{k} and
\code{knots} are specified, then \code{k} takes precendence.}

\item{control}{A list with parameters. Use \code{control_brokenstick()}
to generate.}

\item{y}{Outcome variable. When \code{x} is a \strong{data frame} or \strong{matrix},
\code{y} is specified as:
\itemize{
\item A \strong{data frame} with 1 numeric column.
\item A \strong{matrix} with 1 numeric column.
\item A numeric \strong{vector}.
}}

\item{group}{Grouping variable. When \code{x} is a \strong{data frame} or \strong{matrix},
\code{group} is specified as:
\itemize{
\item A \strong{data frame} with 1 column.
\item A \strong{matrix} with 1 column.
\item A numeric \strong{vector}.
}}
}
\value{
A \code{brokenstick} object.
}
\description{
The \code{brokenstick()} function fits an irregularly observed series
of measurements onto a user-specified grid of points.
The model codes de grid by a series of linear B-splines.
Differences between observations are expressed by one random
effect per grid point. When multiple set of series are modelled,
each modeled trajectory consists of straight lines that join at the
chosen grid points, and hence look like a broken stick.
}
\details{
The variance-covariance matrix of the random effects absorbs the
relations over time. Currently, this matrix is estimated
as unstructured by \code{\link[lme4:lmer]{lme4::lmer()}}.
This estimate may be unstable if
the number of children is small relative to the number of specified
knots. The function can be time consuming for data sets with thousands of
children.
}
\examples{
data <- brokenstick::smocc_200

# fit with implicit boundary c(0, 3)
# fit <- with(data, brokenstick(x = data.frame(age), y = hgt.z, group = id, knots = 0:3))
fit <- brokenstick(hgt.z ~ age | id, data = data, knots = 0:3)

# Formula interface
mod1 <- brokenstick(mpg ~ disp | cyl, mtcars)

# Recipes data.frame interface
library(recipes)
rec <- recipe(mtcars,
              vars = c("mpg", "disp", "cyl"),
              roles = c("outcome", "predictor", "group"))
mod2 <- brokenstick(rec, mtcars)
identical(mod1, mod2)

# XY interface - data.frame
mod3 <- with(mtcars, brokenstick(data.frame(disp), mpg, cyl))
identical(mod1, mod3)

# XY interface - matrix
mt <- as.matrix(mtcars)
mod4 <- brokenstick(mt[, "disp", drop = FALSE],
                    mt[, "mpg", drop = FALSE],
                    mt[, "cyl", drop = FALSE])

}
