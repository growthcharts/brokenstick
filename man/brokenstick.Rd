% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/brokenstick.R
\name{brokenstick}
\alias{brokenstick}
\alias{brokenstick.default}
\alias{brokenstick.data.frame}
\alias{brokenstick.matrix}
\alias{brokenstick.formula}
\alias{brokenstick.recipe}
\title{Fit a `brokenstick` model to irregular data}
\usage{
brokenstick(x, ...)

\method{brokenstick}{default}(x, ...)

\method{brokenstick}{data.frame}(x, y, ...)

\method{brokenstick}{matrix}(x, y, ...)

\method{brokenstick}{formula}(formula, data, ...)

\method{brokenstick}{recipe}(x, data, ...)
}
\arguments{
\item{x}{Predictor variables. Depending on the context:

  * A __data frame__ of predictors.
  * A __matrix__ of predictors.
  * A __recipe__ specifying a set of preprocessing steps
    created from [recipes::recipe()].

The current model accepts only one predictor (by
default the first column in __data frame__ or __matrix__) and only
one group variable (by default the last column in
__data frame__ or __matrix__).}

\item{...}{Not currently used, but required for extensibility.}

\item{y}{Outcome variable. When `x` is a __data frame__ or __matrix__,
`y` is specified as:

  * A __data frame__ with 1 numeric column.
  * A __matrix__ with 1 numeric column.
  * A numeric __vector__.}

\item{formula}{A formula specifying the outcome terms on the
left-hand side, the predictor term on the right-hand side and
the group variable after the `|` sign, e.g `formula = hgt ~ age | id`.}

\item{data}{When a __recipe__ or __formula__ is used, `data` is specified as:

  * A __data frame__ containing predictor, group and outcome variables.}

\item{knots}{optional, numerical vector with the locations of the breaks to be
placed on the values of the predictor. Values outside the range of the data
will extend the `boundary` knots (see below) beyond the data range.}

\item{boundary}{optional, numerical vector of length 2 with the left and
right boundary knots. The `boundary` setting is passed to
__splines::bs()__ as the `Boundary.knots` argument. If not specified,
then the range of predictor variable is taken. Since the range
depends on the data, it is recommended to specify `boundary` explicitly.
Note the the `boundary` range is internally expanded to include at
least `range(knots)`.}

\item{k}{optional, a convenience parameter giving the number of
internal knots. If specified, then `k` internal knots are placed
at equidense quantiles of the predictor. For example,
specifying `k = 1` puts a knot at the 50th quantile (median),
setting `k = 3` puts knots at the 25th, 50th and 75th quantiles,
and so on. Note that knots specified via `k` are data-dependent
and do not transfer well to other data sets. We therefore recommend
using `knots` and `boundary` over `k`. If both `k`` and
`knots` are specified, then `k` take precendence. This is likely
to change in the future.}

\item{method}{Either `"kr"` (for the Kasim-Raudenbush sampler)
or `"lmer"` (for __lme4::lmer__).}

\item{control}{A list with arguments that can be used to control the
fitting of \code{lmer()}. The default
is set to \code{lmerControl(check.nobs.vs.nRE = "warning")}, which turn
fatal errors with respect the number of parameters into warnings.}

\item{na.action}{The function to call for the \code{na.action} argument
in \code{lmer()}. The default is \code{na.exclude}.}
}
\value{
A `brokenstick` object.
}
\description{
`brokenstick()` fits an irregularly observed series
of measurements onto a user-specified grid of points.
The model codes de grid by a series of linear B-splines.
Differences between observations are expressed by one random
effect per grid point. When multiple set of series are modelled,
each modeled trajectory consists of straight lines that join at the
chosen grid points, and hence look like a 'broken stick'.
}
\details{
The variance-covariance matrix of the random effects absorbs the
relations over time. Currently, this matrix is estimated
as unstructured by \code{lmer()} from the \code{lme4} package.
This estimate may be unstable if
the number of children is small relative to the number of specified
knots. The function can be time consuming for data sets with thousands of
children.
}
\examples{
# data <- brokenstick::smocc_200

# fit with implicit boundary c(0, 3)
# fit <- with(data, brokenstick(y = hgt.z, x = age, subjid = id, knots = 0:3))

\dontrun{
predictors <- mtcars[, -1]
outcome <- mtcars[, 1]

# XY interface
mod <- brokenstick(predictors, outcome)

# Formula interface
mod2 <- brokenstick(mpg ~ ., mtcars)

# Recipes interface
library(recipes)
rec <- recipe(mpg ~ ., mtcars)
rec <- step_log(rec, disp)
mod3 <- brokenstick(rec, mtcars)
}
}
